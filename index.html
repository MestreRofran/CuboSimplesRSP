<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CuboFotos Rofran & Laís</title>
    <style>
        body { 
            background: #111; color: white; margin: 0; 
            display: flex; flex-direction: column; align-items: center; 
            justify-content: center; height: 100vh; overflow: hidden;
            font-family: 'Segoe UI', sans-serif; perspective: 1200px;
            touch-action: none;
        }
        
        /* Interface Superior Ajustada */
        .interface { 
            position: absolute; top: 10px; text-align: center; z-index: 10; 
            background: rgba(0,0,0,0.8); padding: 12px; border-radius: 12px; 
            width: 92%; max-width: 380px; border: 1px solid #333;
        }
        
        .controles-topo { 
            display: flex; gap: 6px; justify-content: center; 
            margin-top: 10px; margin-bottom: 10px; 
        }

        /* Botões Menores */
        button {
            background: #2980b9; border: none; padding: 8px 10px;
            color: white; font-weight: bold; cursor: pointer; border-radius: 6px;
            font-size: 10px; flex: 1; text-transform: uppercase;
            transition: 0.2s;
        }
        button.reset { background: #c0392b; }
        button.auto { background: #27ae60; }
        button:active { transform: scale(0.95); }

        .speed-box { 
            color: #ccc; display: flex; align-items: center; 
            justify-content: center; gap: 8px; font-size: 11px; 
        }
        
        /* Configuração do Cubo */
        .scene {
            width: 280px; height: 280px;
            display: flex; align-items: center; justify-content: center;
            transform-style: preserve-3d;
            margin-top: 60px; /* Espaço para não bater nos botões */
        }

        .cube-inner {
            width: 0; height: 0;
            position: relative;
            transform-style: preserve-3d;
            transform: rotateX(-25deg) rotateY(35deg);
        }

        .cubie {
            position: absolute;
            width: 90px; height: 90px;
            transform-style: preserve-3d;
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            left: -45px; top: -45px; 
        }

        .face {
            position: absolute; width: 100%; height: 100%;
            background: #222; border: 1px solid #000;
            box-sizing: border-box; background-size: 270px 270px;
            backface-visibility: hidden;
        }

        .f-front  { transform: rotateY(0deg) translateZ(45px); }
        .f-back   { transform: rotateY(180deg) translateZ(45px); }
        .f-right  { transform: rotateY(90deg) translateZ(45px); }
        .f-left   { transform: rotateY(-90deg) translateZ(45px); }
        .f-top    { transform: rotateX(90deg) translateZ(45px); }
        .f-bottom { transform: rotateX(-90deg) translateZ(45px); }
    </style>
</head>
<body>

    <div class="interface">
        <h4 style="margin:0; font-size: 14px;">Cubo Rofran & Laís</h4>
        
        <div class="controles-topo">
            <button onclick="scramble()">Misturar</button>
            <button class="reset" onclick="solveCube()">Reordenar</button>
            <button id="btnAuto" class="auto" onclick="toggleAuto()">Parar de Girar</button>
        </div>

        <div class="speed-box">
            Velocidade: <input type="range" id="speedRange" min="0" max="10" value="2" style="width: 100px;">
        </div>
    </div>

    <div class="scene">
        <div class="cube-inner" id="cube"></div>
    </div>

    <script>
        const container = document.getElementById('cube');
        const speedInput = document.getElementById('speedRange');
        const btnAuto = document.getElementById('btnAuto');

        function driveLink(id) { return `https://drive.google.com/thumbnail?sz=w1000&id=${id}`; }
        
        const images = [
            driveLink('1tr4-tuj1VpUK7PulXV2ZHLAOfrlaL34y'),
            driveLink('19XLlXBJ4avejB_zXKUPrLmFjQIZZaPkX'),
            driveLink('1JpHOpHZ_QSiPEefTNalCU3snED4PFI-J'),
            driveLink('1PSarH8G_zHWevSXqdFonqnAhUi29iRE3'),
            driveLink('1iRxhw4Gv1etAHlD1iMYDfalZRUnlijlA'),
            driveLink('1nGk-nQG0eQobKI1lteTe2a8OAW98CnJj')
        ];

        let cubies = [];
        let moveStack = [];
        let isAutoRotating = true;
        let isAnimating = false;
        let rotX = -25, rotY = 35;
        let isDragging = false, lastX, lastY;

        function createCube() {
            container.innerHTML = '';
            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    for (let z = -1; z <= 1; z++) {
                        const cubie = document.createElement('div');
                        cubie.className = 'cubie';
                        cubie.dataset.x = x; cubie.dataset.y = y; cubie.dataset.z = z;

                        ['f-front', 'f-back', 'f-right', 'f-left', 'f-top', 'f-bottom'].forEach((cls, i) => {
                            const face = document.createElement('div');
                            face.className = `face ${cls}`;
                            face.style.backgroundImage = `url(${images[i]})`;
                            let u, v;
                            if (cls === 'f-front') { u = x; v = y; }
                            if (cls === 'f-back')  { u = -x; v = y; }
                            if (cls === 'f-right') { u = -z; v = y; }
                            if (cls === 'f-left')  { u = z; v = y; }
                            if (cls === 'f-top')   { u = x; v = z; }
                            if (cls === 'f-bottom'){ u = x; v = -z; }
                            face.style.backgroundPosition = `${(u + 1) * 50}% ${(v + 1) * 50}%`;
                            cubie.appendChild(face);
                        });
                        updatePos(cubie);
                        container.appendChild(cubie);
                        cubies.push(cubie);
                    }
                }
            }
        }

        function updatePos(el) {
            const tx = el.dataset.x * 90, ty = el.dataset.y * 90, tz = el.dataset.z * 90;
            el.style.transform = `translate3d(${tx}px, ${ty}px, ${tz}px) ${el.dataset.rot || ""}`;
        }

        function rotateLayer(axis, layer, angle, record = true) {
            if (record) moveStack.push({ axis, layer, angle });
            cubies.forEach(c => {
                const pos = { x: parseFloat(c.dataset.x), y: parseFloat(c.dataset.y), z: parseFloat(c.dataset.z) };
                if (Math.round(pos[axis]) === layer) {
                    const rad = angle * (Math.PI / 180);
                    const cos = Math.round(Math.cos(rad)), sin = Math.round(Math.sin(rad));
                    let x = pos.x, y = pos.y, z = pos.z;
                    if (axis === 'z') { [c.dataset.x, c.dataset.y] = [x * cos - y * sin, x * sin + y * cos]; }
                    if (axis === 'x') { [c.dataset.y, c.dataset.z] = [y * cos - z * sin, y * sin + z * cos]; }
                    if (axis === 'y') { [c.dataset.x, c.dataset.z] = [x * cos + z * sin, -x * sin + z * cos]; }
                    c.dataset.rot = `rotate${axis.toUpperCase()}(${angle}deg) ${c.dataset.rot || ""}`;
                    updatePos(c);
                }
            });
        }

        async function scramble() {
            if (isAnimating) return; isAnimating = true;
            for (let i = 0; i < 8; i++) {
                rotateLayer(['x','y','z'][Math.floor(Math.random()*3)], Math.floor(Math.random()*3)-1, 90);
                await new Promise(r => setTimeout(r, 450));
            }
            isAnimating = false;
        }

        async function solveCube() {
            if (isAnimating || moveStack.length === 0) return;
            isAnimating = true;
            while (moveStack.length > 0) {
                const m = moveStack.pop();
                rotateLayer(m.axis, m.layer, -m.angle, false);
                await new Promise(r => setTimeout(r, 450));
            }
            isAnimating = false;
        }

        function toggleAuto() {
            isAutoRotating = !isAutoRotating;
            btnAuto.innerText = isAutoRotating ? "Parar" : "Girar";
        }

        function startDrag(e) {
            if(e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') return;
            isDragging = true;
            lastX = e.touches ? e.touches[0].clientX : e.clientX;
            lastY = e.touches ? e.touches[0].clientY : e.clientY;
        }

        function moveDrag(e) {
            if (!isDragging) return;
            let currentX = e.touches ? e.touches[0].clientX : e.clientX;
            let currentY = e.touches ? e.touches[0].clientY : e.clientY;
            rotY += (currentX - lastX) * 0.5;
            rotX -= (currentY - lastY) * 0.5;
            container.style.transform = `rotateX(${rotX}deg) rotateY(${rotY}deg)`;
            lastX = currentX; lastY = currentY;
        }

        document.addEventListener('mousedown', startDrag);
        document.addEventListener('touchstart', startDrag);
        document.addEventListener('mousemove', moveDrag);
        document.addEventListener('touchmove', moveDrag);
        document.addEventListener('mouseup', () => isDragging = false);
        document.addEventListener('touchend', () => isDragging = false);

        function autoRotateLoop() {
            if (isAutoRotating && !isDragging) {
                rotY += parseFloat(speedInput.value) * 0.3;
                container.style.transform = `rotateX(${rotX}deg) rotateY(${rotY}deg)`;
            }
            requestAnimationFrame(autoRotateLoop);
        }

        createCube();
        autoRotateLoop();
    </script>
</body>
</html>
